# üóÑ Introduction to SQL

SQL (**Structured Query Language**) is used to interact with relational databases ‚Äî to store, retrieve, update, and manage data.

---

## üìå Basic SQL Commands
| Command  | Purpose                    | Example                                                |
| -------- | -------------------------- | ------------------------------------------------------ |
| `SELECT` | Retrieve data from a table | `SELECT * FROM employees;`                             |
| `INSERT` | Add new data               | `INSERT INTO employees (id, name) VALUES (1, 'John');` |
| `UPDATE` | Modify existing data       | `UPDATE employees SET name = 'Jane' WHERE id = 1;`     |
| `DELETE` | Remove data                | `DELETE FROM employees WHERE id = 1;`                  |

---

## üîç Filtering & Sorting Data
- **Filter with WHERE**: `SELECT * FROM employees WHERE department = 'IT';`
- **Sort with ORDER BY**: `SELECT * FROM employees ORDER BY name ASC;`
- **Combine**:  
```sql
SELECT * 
FROM employees
WHERE salary > 50000
ORDER BY salary DESC;
```

## Joins
| Join Type      | Returns                            | Syntax                                    |
| -------------- | ---------------------------------- | ----------------------------------------- |
| **INNER JOIN** | Only matching rows in both tables  | `... FROM A INNER JOIN B ON A.id = B.id;` |
| **LEFT JOIN**  | All from left + matches from right | `... FROM A LEFT JOIN B ON A.id = B.id;`  |
| **RIGHT JOIN** | All from right + matches from left | `... FROM A RIGHT JOIN B ON A.id = B.id;` |
| **FULL JOIN**  | All rows from both tables          | `... FROM A FULL JOIN B ON A.id = B.id;`  |
## Aggregation Functions
|Function|Description|Example|
|---|---|---|
|`COUNT()`|Number of rows|`SELECT COUNT(*) FROM employees;`|
|`SUM()`|Total sum|`SELECT SUM(salary) FROM employees;`|
|`AVG()`|Average value|`SELECT AVG(salary) FROM employees;`|
|`MIN()`|Smallest value|`SELECT MIN(salary) FROM employees;`|
|`MAX()`|Largest value|`SELECT MAX(salary) FROM employees;`|
##  üìä Grouping Data

- **GROUP BY**: Groups rows with same values in columns.
- **HAVING**: Filters groups (works like WHERE but after grouping).

```sql
SELECT department, COUNT(*) AS emp_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;
```

## üîÑ Subqueries & Nested Queries

- **Subquery**: Query inside another query.

```sql
SELECT name
FROM employees
WHERE dept_id = (
    SELECT id FROM departments WHERE name = 'IT'
);
```

- **Nested Query**: Multiple levels of subqueries inside each other.

```sql
SELECT name
FROM employees
WHERE dept_id IN (
    SELECT id
    FROM departments
    WHERE location_id IN (
        SELECT id
        FROM locations
        WHERE city = 'Mumbai'
    )
);
```

## **CTEs (Common Table Expressions)**

A **CTE** is like a _temporary, named result set_ you can use in your main query ‚Äî makes long queries easier to read and maintain.

```sql
WITH cte_name AS (
    SELECT dept_id, COUNT(*) AS emp_count
    FROM employees
    GROUP BY dept_id
)
SELECT *
FROM cte_name
WHERE emp_count > 5;
```

## **Window Functions**

Window functions perform calculations **across a set of rows related to the current row**, without collapsing them into a single result (unlike `GROUP BY`).

```sql
function_name(expression) 
OVER (
    PARTITION BY column   -- optional: groups like GROUP BY
    ORDER BY column       -- optional: defines row order
)
```

**Examples:**
#### Rank employees by salary within each department
```sql
SELECT 
    name, 
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_in_dept
FROM employees;
```

#### Running total of sales
```sql
SELECT 
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) AS running_total
FROM sales;
```

## **Collapsing** (GROUP BY, regular aggregations)

- **What happens:**  
    SQL **groups rows together** and produces **one row per group** ‚Äî the original row detail is **lost**.
    
- You _collapse_ multiple rows into fewer rows.
## **Not Collapsing** (Window Functions)

- **What happens:**  
    SQL **keeps all original rows**, but **adds an extra column** with the calculation.
    
- You _don‚Äôt collapse_ anything ‚Äî the detail stays, and the calculation is ‚Äúoverlaid‚Äù on the data.

